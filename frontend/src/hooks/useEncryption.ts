import { useState, useEffect, useCallback } from 'react';\nimport { ethers } from 'ethers';\nimport { FHEManager, getFHEManager } from '../utils/encryption';\nimport { EncryptionContext } from '../types';\nimport toast from 'react-hot-toast';\n\nexport const useEncryption = (provider?: ethers.Provider) => {\n  const [context, setContext] = useState<EncryptionContext>({\n    publicKey: null,\n    isInitialized: false,\n    error: null,\n  });\n\n  const [fheManager, setFheManager] = useState<FHEManager | null>(null);\n  const [isInitializing, setIsInitializing] = useState(false);\n\n  useEffect(() => {\n    if (provider) {\n      initializeEncryption();\n    }\n  }, [provider]);\n\n  const initializeEncryption = useCallback(async () => {\n    if (isInitializing) return;\n    \n    setIsInitializing(true);\n    setContext(prev => ({ ...prev, error: null }));\n\n    try {\n      const manager = getFHEManager(provider);\n      await manager.initialize();\n      \n      setFheManager(manager);\n      setContext({\n        publicKey: manager.getPublicKey(),\n        isInitialized: true,\n        error: null,\n      });\n      \n      toast.success('Encryption initialized successfully');\n    } catch (error: any) {\n      const errorMessage = error.message || 'Failed to initialize encryption';\n      setContext(prev => ({\n        ...prev,\n        error: errorMessage,\n      }));\n      toast.error(errorMessage);\n    } finally {\n      setIsInitializing(false);\n    }\n  }, [provider, isInitializing]);\n\n  const encryptValue = useCallback(async (value: number | bigint): Promise<string> => {\n    if (!fheManager || !context.isInitialized) {\n      throw new Error('Encryption not initialized');\n    }\n\n    try {\n      return await fheManager.encryptUint64(value);\n    } catch (error: any) {\n      const errorMessage = error.message || 'Failed to encrypt value';\n      toast.error(errorMessage);\n      throw error;\n    }\n  }, [fheManager, context.isInitialized]);\n\n  const decryptValue = useCallback(async (\n    encryptedValue: string,\n    userAddress: string\n  ): Promise<bigint> => {\n    if (!fheManager || !context.isInitialized) {\n      throw new Error('Encryption not initialized');\n    }\n\n    try {\n      return await fheManager.decryptUint64(encryptedValue, userAddress);\n    } catch (error: any) {\n      const errorMessage = error.message || 'Failed to decrypt value';\n      toast.error(errorMessage);\n      throw error;\n    }\n  }, [fheManager, context.isInitialized]);\n\n  const canDecryptValue = useCallback((\n    userAddress: string,\n    encryptedValue: string\n  ): boolean => {\n    if (!fheManager || !context.isInitialized) {\n      return false;\n    }\n\n    return fheManager.canDecrypt(userAddress, encryptedValue);\n  }, [fheManager, context.isInitialized]);\n\n  const encryptSalary = useCallback(async (salaryInCents: number): Promise<string> => {\n    if (salaryInCents <= 0) {\n      throw new Error('Salary must be greater than 0');\n    }\n\n    return await encryptValue(salaryInCents);\n  }, [encryptValue]);\n\n  const encryptBonus = useCallback(async (bonusInCents: number): Promise<string> => {\n    if (bonusInCents < 0) {\n      throw new Error('Bonus cannot be negative');\n    }\n\n    return await encryptValue(bonusInCents);\n  }, [encryptValue]);\n\n  const decryptSalary = useCallback(async (\n    encryptedSalary: string,\n    userAddress: string\n  ): Promise<number> => {\n    const decryptedValue = await decryptValue(encryptedSalary, userAddress);\n    return Number(decryptedValue);\n  }, [decryptValue]);\n\n  const decryptBonus = useCallback(async (\n    encryptedBonus: string,\n    userAddress: string\n  ): Promise<number> => {\n    const decryptedValue = await decryptValue(encryptedBonus, userAddress);\n    return Number(decryptedValue);\n  }, [decryptValue]);\n\n  const createEncryptedValue = useCallback(async (\n    value: number | bigint,\n    userAddress: string\n  ) => {\n    const encryptedData = await encryptValue(value);\n    const canDecrypt = canDecryptValue(userAddress, encryptedData);\n    \n    return {\n      data: encryptedData,\n      isEncrypted: true,\n      canDecrypt,\n    };\n  }, [encryptValue, canDecryptValue]);\n\n  const batchEncrypt = useCallback(async (\n    values: (number | bigint)[]\n  ): Promise<string[]> => {\n    if (!fheManager || !context.isInitialized) {\n      throw new Error('Encryption not initialized');\n    }\n\n    try {\n      const encryptedValues = await Promise.all(\n        values.map(value => encryptValue(value))\n      );\n      return encryptedValues;\n    } catch (error: any) {\n      toast.error('Failed to encrypt batch values');\n      throw error;\n    }\n  }, [fheManager, context.isInitialized, encryptValue]);\n\n  const validateEncryptedValue = useCallback((encryptedValue: string): boolean => {\n    return encryptedValue.startsWith('0xenc_') && encryptedValue.length > 10;\n  }, []);\n\n  const reset = useCallback(() => {\n    setFheManager(null);\n    setContext({\n      publicKey: null,\n      isInitialized: false,\n      error: null,\n    });\n  }, []);\n\n  return {\n    ...context,\n    isInitializing,\n    fheManager,\n    initializeEncryption,\n    encryptValue,\n    decryptValue,\n    canDecryptValue,\n    encryptSalary,\n    encryptBonus,\n    decryptSalary,\n    decryptBonus,\n    createEncryptedValue,\n    batchEncrypt,\n    validateEncryptedValue,\n    reset,\n  };\n};"
import { useState, useCallback, useEffect } from 'react';\nimport { ethers } from 'ethers';\nimport { PAYROLL_ABI } from '../contracts/PayrollABI';\nimport { CONTRACT_ADDRESSES } from '../utils/constants';\nimport { Employee, PayrollEntry, ComplianceReport, UserRole } from '../types';\nimport { useEncryption } from './useEncryption';\nimport toast from 'react-hot-toast';\n\nexport const usePayrollContract = (provider?: ethers.Provider, signer?: ethers.Signer) => {\n  const [contract, setContract] = useState<ethers.Contract | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const { encryptValue, decryptValue, canDecryptValue } = useEncryption(provider);\n\n  useEffect(() => {\n    if (provider && CONTRACT_ADDRESSES.payrollContract !== '0x0000000000000000000000000000000000000000') {\n      const contractInstance = new ethers.Contract(\n        CONTRACT_ADDRESSES.payrollContract,\n        PAYROLL_ABI,\n        signer || provider\n      );\n      setContract(contractInstance);\n    }\n  }, [provider, signer]);\n\n  const handleContractCall = async <T,>(\n    operation: string,\n    contractCall: () => Promise<T>\n  ): Promise<T | null> => {\n    if (!contract) {\n      const error = 'Contract not initialized';\n      setError(error);\n      toast.error(error);\n      return null;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const result = await contractCall();\n      toast.success(`${operation} completed successfully`);\n      return result;\n    } catch (error: any) {\n      const errorMessage = error.reason || error.message || `Failed to ${operation.toLowerCase()}`;\n      setError(errorMessage);\n      toast.error(errorMessage);\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Employee Management\n  const addEmployee = useCallback(async (\n    employeeAddress: string,\n    name: string,\n    position: string,\n    salaryInCents: number\n  ): Promise<boolean> => {\n    if (!signer) {\n      toast.error('Signer required for transactions');\n      return false;\n    }\n\n    const result = await handleContractCall('Add Employee', async () => {\n      const encryptedSalary = await encryptValue(salaryInCents);\n      const tx = await contract!.addEmployee(employeeAddress, name, position, encryptedSalary);\n      await tx.wait();\n      return true;\n    });\n\n    return result || false;\n  }, [contract, signer, encryptValue]);\n\n  const removeEmployee = useCallback(async (employeeAddress: string): Promise<boolean> => {\n    if (!signer) {\n      toast.error('Signer required for transactions');\n      return false;\n    }\n\n    const result = await handleContractCall('Remove Employee', async () => {\n      const tx = await contract!.removeEmployee(employeeAddress);\n      await tx.wait();\n      return true;\n    });\n\n    return result || false;\n  }, [contract, signer]);\n\n  const getEmployeeInfo = useCallback(async (\n    employeeAddress: string,\n    currentUserAddress: string\n  ): Promise<Employee | null> => {\n    const result = await handleContractCall('Get Employee Info', async () => {\n      const [name, position, isActive, hireDate] = await contract!.getEmployeeInfo(employeeAddress);\n      const encryptedSalary = await contract!.getEncryptedSalary(employeeAddress);\n      \n      const canDecrypt = canDecryptValue(currentUserAddress, encryptedSalary);\n      \n      return {\n        id: employeeAddress,\n        address: employeeAddress,\n        name,\n        position,\n        baseSalary: {\n          data: encryptedSalary,\n          isEncrypted: true,\n          canDecrypt,\n        },\n        isActive,\n        hireDate: new Date(Number(hireDate) * 1000).toISOString(),\n      };\n    });\n\n    return result;\n  }, [contract, canDecryptValue]);\n\n  // Payroll Processing\n  const processPayroll = useCallback(async (employeeAddresses: string[]): Promise<boolean> => {\n    if (!signer) {\n      toast.error('Signer required for transactions');\n      return false;\n    }\n\n    const result = await handleContractCall('Process Payroll', async () => {\n      const tx = await contract!.processPayroll(employeeAddresses);\n      await tx.wait();\n      return true;\n    });\n\n    return result || false;\n  }, [contract, signer]);\n\n  const distributeBonus = useCallback(async (\n    employeeAddresses: string[],\n    bonusAmountsInCents: number[]\n  ): Promise<boolean> => {\n    if (!signer) {\n      toast.error('Signer required for transactions');\n      return false;\n    }\n\n    if (employeeAddresses.length !== bonusAmountsInCents.length) {\n      toast.error('Employee addresses and bonus amounts must match');\n      return false;\n    }\n\n    const result = await handleContractCall('Distribute Bonus', async () => {\n      const encryptedBonuses = await Promise.all(\n        bonusAmountsInCents.map(amount => encryptValue(amount))\n      );\n      \n      const tx = await contract!.distributeBonus(employeeAddresses, encryptedBonuses);\n      await tx.wait();\n      return true;\n    });\n\n    return result || false;\n  }, [contract, signer, encryptValue]);\n\n  // Payment History\n  const getPaymentHistory = useCallback(async (\n    employeeAddress: string,\n    currentUserAddress: string\n  ): Promise<PayrollEntry[]> => {\n    const result = await handleContractCall('Get Payment History', async () => {\n      const paymentCount = await contract!.getPaymentCount(employeeAddress);\n      const payments: PayrollEntry[] = [];\n      \n      for (let i = 0; i < Number(paymentCount); i++) {\n        const [encryptedAmount, timestamp, paymentType] = await contract!.getPaymentHistory(employeeAddress, i);\n        \n        const canDecrypt = canDecryptValue(currentUserAddress, encryptedAmount);\n        \n        payments.push({\n          id: `${employeeAddress}-${i}`,\n          employeeId: employeeAddress,\n          employeeName: '', // Would need to get from employee info\n          baseSalary: {\n            data: encryptedAmount,\n            isEncrypted: true,\n            canDecrypt,\n          },\n          bonus: {\n            data: '0',\n            isEncrypted: false,\n            canDecrypt: false,\n          },\n          deductions: {\n            data: '0',\n            isEncrypted: false,\n            canDecrypt: false,\n          },\n          netPay: {\n            data: encryptedAmount,\n            isEncrypted: true,\n            canDecrypt,\n          },\n          payPeriod: new Date(Number(timestamp) * 1000).toISOString().slice(0, 7),\n          processedAt: new Date(Number(timestamp) * 1000).toISOString(),\n          status: 'completed',\n        });\n      }\n      \n      return payments;\n    });\n\n    return result || [];\n  }, [contract, canDecryptValue]);\n\n  // Role Management\n  const getUserRole = useCallback(async (userAddress: string): Promise<UserRole | null> => {\n    const result = await handleContractCall('Get User Role', async () => {\n      const roleNumber = await contract!.getUserRole(userAddress);\n      const roles = [UserRole.EMPLOYEE, UserRole.EMPLOYER, UserRole.ADMIN, UserRole.AUDITOR];\n      return roles[Number(roleNumber)] || UserRole.EMPLOYEE;\n    });\n\n    return result;\n  }, [contract]);\n\n  const setUserRole = useCallback(async (\n    userAddress: string,\n    role: UserRole\n  ): Promise<boolean> => {\n    if (!signer) {\n      toast.error('Signer required for transactions');\n      return false;\n    }\n\n    const result = await handleContractCall('Set User Role', async () => {\n      const roleMapping = {\n        [UserRole.EMPLOYEE]: 0,\n        [UserRole.EMPLOYER]: 1,\n        [UserRole.ADMIN]: 2,\n        [UserRole.AUDITOR]: 3,\n      };\n      \n      const tx = await contract!.setUserRole(userAddress, roleMapping[role]);\n      await tx.wait();\n      return true;\n    });\n\n    return result || false;\n  }, [contract, signer]);\n\n  // Compliance & Reporting\n  const generateComplianceReport = useCallback(async (\n    reportType: string,\n    period: string,\n    currentUserAddress: string\n  ): Promise<ComplianceReport | null> => {\n    const result = await handleContractCall('Generate Compliance Report', async () => {\n      const [encryptedTotalPayroll, encryptedAverageSalary, employeeCount] = \n        await contract!.generateComplianceReport(reportType, period);\n      \n      const canDecryptTotal = canDecryptValue(currentUserAddress, encryptedTotalPayroll);\n      const canDecryptAverage = canDecryptValue(currentUserAddress, encryptedAverageSalary);\n      \n      return {\n        id: `${reportType}-${period}-${Date.now()}`,\n        reportType: reportType as 'tax' | 'audit' | 'compliance',\n        period,\n        totalEmployees: Number(employeeCount),\n        totalPayroll: {\n          data: encryptedTotalPayroll,\n          isEncrypted: true,\n          canDecrypt: canDecryptTotal,\n        },\n        averageSalary: {\n          data: encryptedAverageSalary,\n          isEncrypted: true,\n          canDecrypt: canDecryptAverage,\n        },\n        generatedAt: new Date().toISOString(),\n        generatedBy: currentUserAddress,\n      };\n    });\n\n    return result;\n  }, [contract, canDecryptValue]);\n\n  // Utility Functions\n  const getActiveEmployeeCount = useCallback(async (): Promise<number> => {\n    const result = await handleContractCall('Get Active Employee Count', async () => {\n      const count = await contract!.getActiveEmployeeCount();\n      return Number(count);\n    });\n\n    return result || 0;\n  }, [contract]);\n\n  const decryptSalaryForUser = useCallback(async (\n    encryptedSalary: string,\n    userAddress: string\n  ): Promise<number | null> => {\n    try {\n      const decryptedValue = await decryptValue(encryptedSalary, userAddress);\n      return Number(decryptedValue);\n    } catch (error) {\n      console.error('Failed to decrypt salary:', error);\n      return null;\n    }\n  }, [decryptValue]);\n\n  // Contract Events\n  const subscribeToEvents = useCallback((eventCallbacks: {\n    onEmployeeAdded?: (employee: string, name: string) => void;\n    onEmployeeRemoved?: (employee: string) => void;\n    onPaymentProcessed?: (employee: string, amount: string, type: string) => void;\n    onPayrollProcessed?: (employeeCount: number, timestamp: number) => void;\n  }) => {\n    if (!contract) return;\n\n    if (eventCallbacks.onEmployeeAdded) {\n      contract.on('EmployeeAdded', eventCallbacks.onEmployeeAdded);\n    }\n    if (eventCallbacks.onEmployeeRemoved) {\n      contract.on('EmployeeRemoved', eventCallbacks.onEmployeeRemoved);\n    }\n    if (eventCallbacks.onPaymentProcessed) {\n      contract.on('PaymentProcessed', eventCallbacks.onPaymentProcessed);\n    }\n    if (eventCallbacks.onPayrollProcessed) {\n      contract.on('PayrollProcessed', eventCallbacks.onPayrollProcessed);\n    }\n\n    return () => {\n      contract.removeAllListeners();\n    };\n  }, [contract]);\n\n  return {\n    contract,\n    isLoading,\n    error,\n    // Employee Management\n    addEmployee,\n    removeEmployee,\n    getEmployeeInfo,\n    // Payroll Processing\n    processPayroll,\n    distributeBonus,\n    // Payment History\n    getPaymentHistory,\n    // Role Management\n    getUserRole,\n    setUserRole,\n    // Compliance\n    generateComplianceReport,\n    // Utilities\n    getActiveEmployeeCount,\n    decryptSalaryForUser,\n    subscribeToEvents,\n  };\n};"